---
title: "Record matching"
author: "Adele Tyson"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/delat/OneDrive/MPhil Population Health Sciences 2022-2023/12 Dissertation")
```

```{r libraries, message = FALSE, warning = FALSE}

library(janitor)
library(Hmisc)
library(readxl)
library(writexl)
library(reclin2)
library(lubridate)
library(RecordLinkage)
library(dgof) # for statistical testing
library(fdm2id) # for predict that works for kmeans
library(ppclust) # for cmeans
library(tidyverse)

```

```{r import commune lookup}
commune_region_lookup <- read_excel("04_Data/Outputs/region_service_commune.xlsx") %>%
  clean_names() %>%
  select(-geometry)
#chile.adm3 <- st_read("04_Data/CHL_adm_humdata/chl_admbnda_adm3_bcn_20211008.shp") %>%
#  mutate(commune_code = str_sub(ADM3_PCODE, start = 3, end = -1))

araucnorte_communes <- commune_region_lookup %>%
  filter(str_detect(health_service_name, "a Norte"))
araucsur_communes <- commune_region_lookup %>%
  filter(str_detect(health_service_name, "a Sur"))

```

```{r import school data}
chile_merged_raw <- read.csv("04_Data/Data_Chile_Merge.csv") %>% clean_names()

chile_merged <- chile_merged_raw %>%
  rename(sex_desc = sex,
         year = agno,
         school_code = rbd,
         school_check_code = dgv_rbd, 
         school_name = nom_rbd,
         school_region_code = cod_reg_rbd,
         school_region_name_abr = nom_reg_rbd_a,
         school_province_code = cod_pro_rbd,
         school_commune_code = cod_com_rbd,
         school_commune_name = nom_com_rbd,
         school_dept_code = cod_deprov_rbd,
         school_dept_name = nom_deprov_rbd,
         school_dependency_code = cod_depe, # has categories 1-6, no1 and no2 here are no1 in grouped
         school_dependency_code_grouped = cod_depe2, # has categories 1-5
         school_rurality_code = rural_rbd,
         school_operation_status = estado_estab, 
         teaching_code1 = cod_ense, # min = 10, max = 910, eg preschool, special education hearing impaired
         teaching_code2 = cod_ense2, # subject matter coding, 1-8
         teaching_code3 = cod_ense3, # age based coding, 1-7
         grade_code1 = cod_grado, # grade of schooling, 1-10, 21-25, 31-34, nests in teaching_code1
         grade_code2 = cod_grado2, # equivalent grade of schooling for adult special education, 1-8, 99
         grade_letter = let_cur, # refers to the class within the grade, close to start of alphabet is higher aptitude
         course_timing = cod_jor, # time of day, morning, afternoon, both, night, no info
         course_type = cod_tip_cur, # 0 = simple course, 1-4 = combined course, 99 = no info
         course_descr = cod_des_cur, # Description of course (TP secondary education only). 0: Does not apply, 1: Only High School, 2: Dual, 3: Other
         student_id = mrun,
         sex = gen_alu, # 0 = no info, 1 = male, 2 = female
         dob = fec_nac_alu_2, # The second one has DD
         age_june30 = edad_alu, # age at 30th June 2021
         special_needs_status = int_alu, # integrated student indicator, 0 = no, 1 = yes. Mostly no
         special_needs_code = cod_int_alu, # ADHD, blindness, etc. 0 = none. 105 = autism, 203 = ADHD. See ER_Matricula_por_alumno_PUBL_MRUN annex 7
         student_region_code = cod_reg_alu,
         student_commune_code = cod_com_alu,
         student_commune_name = nom_com_alu,
         economic_sector_code = cod_sec,
         economic_specialty_code = cod_espe,
         economic_branch_code = cod_rama,
         economic_profspec_code = cod_men,
         teaching_code_new = ens) %>%
  mutate(commune_code = ifelse(nchar(as.character(student_commune_code)) == 4,
                               paste0("0", as.character(student_commune_code)),
                               as.character(student_commune_code)))


```

```{r import clinical data}
clinical_large_raw <- read_excel("04_Data/dataset_ssas_2015_2021.xlsx") %>% clean_names
#describe(clinical_raw)

clinical_large <- clinical_large_raw %>%
  select(c(-procedence, -ethnicity, -education_level, -disability, -foster_care)) %>%
  # Fix the date columns
  mutate(dob_eng = ifelse(str_detect(date_of_birth, "/"), 1,
                   ifelse(str_detect(date_of_birth, "-"), 0, NA)),
         apt_eng = ifelse(str_detect(date_appointment, "/"), 1, ifelse(str_detect(date_appointment, "-"), 0, NA)),
         dob_day = ifelse(dob_eng == 1, as.integer(str_extract(date_of_birth, "^\\d+")), 
                   ifelse(dob_eng == 0, as.integer(str_extract(date_of_birth, "^\\d+")), NA)),
         dob_month = ifelse(dob_eng == 1, as.integer(str_extract(date_of_birth, "(?<=/)\\d+(?=/)")), 
                     ifelse(dob_eng == 0, str_extract(date_of_birth, "(?<=-)\\w+(?=-)"), NA)),
         dob_year = ifelse(dob_eng == 1, as.integer(str_extract(date_of_birth, "\\d+$")), 
                    ifelse(dob_eng == 0, as.integer(str_extract(date_of_birth, "\\d+$")) + 2000, NA)),
         dob_month_eng = as.integer(ifelse(dob_month == "ene", 1,
                                    ifelse(dob_month == "abr", 4, 
                                    ifelse(dob_month == "ago", 8, 
                                    ifelse(dob_month == "sept", 9, 
                                    ifelse(dob_month == "dic", 12, dob_month)))))),
         dob = make_date(year = dob_year, month = dob_month_eng, day = dob_day),
         apt_day = ifelse(apt_eng == 1, as.integer(str_extract(date_appointment, "^\\d+")), 
                   ifelse(apt_eng == 0, as.integer(str_extract(date_appointment, "^\\d+")), NA)),
         apt_month = ifelse(apt_eng == 1, as.integer(str_extract(date_appointment, "(?<=/)\\d+(?=/)")), 
                     ifelse(apt_eng == 0, str_extract(date_appointment, "(?<=-)\\w+(?=-)"), NA)),
         apt_year = ifelse(apt_eng == 1, as.integer(str_extract(date_appointment, "\\d+$")), 
                    ifelse(apt_eng == 0, as.integer(str_extract(date_appointment, "\\d+$")) + 2000, NA)),
         apt_month_eng = as.integer(ifelse(apt_month == "ene", 1,
                                    ifelse(apt_month == "abr", 4, 
                                    ifelse(apt_month == "ago", 8, 
                                    ifelse(apt_month == "sept", 9, 
                                    ifelse(apt_month == "dic", 12, apt_month)))))),
         apt_date = make_date(year = apt_year, month = apt_month_eng, day = apt_day),
         age_june30 = trunc(time_length(interval(ymd(dob), ymd("2021-06-30")), unit = "year")),
         commune_name_upper = ifelse(comuna == "CHOL CHOL", "CHOLCHOL",
                        ifelse(comuna == "CURACAUTIN", "CURACAUTÍN",
                        ifelse(comuna == "PITRUFQUEN", "PITRUFQUÉN",
                        ifelse(comuna == "PUCON", "PUCÓN",
                        ifelse(comuna == "TOLTEN", "TOLTÉN",
                        ifelse(comuna == "VILCUN", "VILCÚN", comuna)))))),
         #commune_name_upper = comuna,
         ses_status = ifelse(socio_economic_level == "FONASA - A", 1, 
                      ifelse(socio_economic_level == "FONASA - B", 2,
                      ifelse(socio_economic_level == "FONASA - C", 2, 
                      ifelse(socio_economic_level == "FONASA - D", 2,
                      ifelse(socio_economic_level == "Private Health Insurance", 3, 
                      ifelse(socio_economic_level %in% c("COLMENA GOLDEN CROSS", "RIO BLANCO", "CARABINEROS (DIPRECA)", "BANMEDICA S.A.", "PARTICULAR (SIN PREVISION)", "VIDA TRES"), 3, NA)))))),
         autism = 1,
         intdisab = 0,
         aut_rank = 1
         ) %>%
  left_join(commune_region_lookup, by = "commune_name_upper") %>%
  select(id, gender, 
         commune_code, commune_name, commune_name_upper, 
         health_service_name, region_name, 
         socio_economic_level, ses_status, 
         dob, age_june30, 
         apt_date, hospital, medical_specialty, type_appointment,
         autism, intdisab, aut_rank) 

aut_codes <- unique(clinical_large_raw$codigo)

clinical_small_raw <- read_excel("04_Data/Dataset_Vill_2014_2021.xlsx", col_names = TRUE) %>% clean_names()

clinical_small <- clinical_small_raw %>%
  rename("dob" = "fecha_nacimiento",
         "apt_date" = "fecha_ejecutada",
         "type_appointment" = "appoinment",
         "diagnosis" = "diagnostico_1") %>%
  mutate(gender = str_to_title(gender),
         autism = ifelse(cod_dg_1 %in% aut_codes | 
                           cod_dg_2 %in% aut_codes | 
                           cod_dg_3 %in% aut_codes, 1, 0),
         aut_rank = ifelse(cod_dg_1 %in% aut_codes, 1,
                    ifelse(cod_dg_2 %in% aut_codes, 2,
                    ifelse(cod_dg_3 %in% aut_codes, 3, NA))),
         age_june30 = trunc(time_length(interval(ymd(dob), ymd("2021-06-30")), unit = "year")),
         commune_name_upper = ifelse(comuna == "CHOL CHOL", "CHOLCHOL",
                        ifelse(comuna == "CURACAUTIN", "CURACAUTÍN", 
                        ifelse(comuna == "PITRUFQUEN", "PITRUFQUÉN", 
                        ifelse(comuna == "PUCON", "PUCÓN", 
                        ifelse(comuna == "TOLTEN", "TOLTÉN", 
                        ifelse(comuna == "VILCUN", "VILCÚN", 
                        ifelse(comuna == "DIEGO DE ALMAGRO  (#)", "DIEGO DE ALMAGRO",
                        ifelse(comuna == "MACHALI", "MACHALÍ",
                        ifelse(comuna == "TEMUCO (##)", "TEMUCO", comuna))))))))),
         ses_status = ifelse(socio_economic_level == "FONASA - A", 1, 
                      ifelse(socio_economic_level == "FONASA - B", 2,
                      ifelse(socio_economic_level == "FONASA - C", 2, 
                      ifelse(socio_economic_level == "FONASA - D", 2,
                      ifelse(socio_economic_level == "Private Health Insurance", 3, 
                      ifelse(socio_economic_level %in% c("COLMENA GOLDEN CROSS", "RIO BLANCO", "CARABINEROS (DIPRECA)", "BANMEDICA S.A.", "PARTICULAR (SIN PREVISION)", "VIDA TRES"), 3, NA))))))
         ) %>%
  left_join(commune_region_lookup, by = "commune_name_upper") %>%
  #filter(autism == 1) %>%
  select(id, gender, commune_code, commune_name, commune_name_upper, health_service_name, region_name, socio_economic_level, ses_status, dob, age_june30, apt_date, hospital, medical_specialty, type_appointment, cod_dg_1, cod_dg_2, cod_dg_3, diagnosis, autism, aut_rank) 
# Throws a warning because there are 2 records for Tocopila which is in two regions. Will keep both because we have no way of knowing which is correct.

intdisab_codes <- unique(c(clinical_small_raw$cod_dg_1, clinical_small_raw$cod_dg_2, clinical_small_raw$cod_dg_3)) %>%
  str_subset("F7") %>%
  sort() 

clinical_small <- clinical_small %>% 
  mutate(intdisab = ifelse(cod_dg_1 %in% intdisab_codes |
                             cod_dg_2 %in% intdisab_codes | 
                             cod_dg_3 %in% intdisab_codes, 1, 0)) %>%
  #rename("codigo" = "cod_dg_1") %>%
  select(c(-cod_dg_1, -cod_dg_2, -cod_dg_3, -diagnosis))

clinical <- rbind(clinical_large, clinical_small)

clinical_communes <- clinical %>% group_by(commune_code) %>% summarise() %>% arrange() %>%
  mutate(commune_in_school_data = ifelse(commune_code %in% unique(chile_merged$commune_code), 1, 0)) # Needs to all be 1's


```

Fixed the date columns because they were in English and Spanish. Redefined the age column to be age at 30th June 2021.

Get one row per person per commune to make matching more efficient. Take the earliest appointment for each person.



```{r restructure clinical}

get.min.na <- function(x) ifelse( !all(is.na(x)), min(x, na.rm = TRUE), NA)
get.max.na <- function(x) ifelse( !all(is.na(x)), max(x, na.rm = TRUE), NA)

patients <- clinical %>%
  filter(commune_code %in% araucsur_communes$commune_code) %>%
  group_by(id, gender, dob, commune_name, region_name) %>% # Maybe move SES back to here
  summarise(ses_status = get.min.na(ses_status),
            autism = get.max.na(autism),
            #intdisab = get.max.na(intdisab),
            aut_rank = get.min.na(aut_rank)) %>%
  ungroup() %>% 
  rename("student_commune_name" = "commune_name",
         "student_region_name" = "region_name",
         "sex_desc" = "gender") %>%
  rowid_to_column("row_id") %>%
  select(row_id, 
         id,
         dob, 
         sex_desc,
         student_commune_name,
         autism,
         ses_status,
         #intdisab,
         aut_rank) #, student_region_name) #, count)
  
write_xlsx(patients, "04_Data/Outputs/patients.xlsx")

length(unique(patients$id))

patients_unique <- patients %>%
  group_by(id) %>%
  summarise(sex_desc = list(sex_desc),
            student_commune_name = list(student_commune_name),
            dob = list(dob),
            ses_status = list(ses_status))
write_csv(patients_unique, "04_Data/Outputs/patients_unique.csv") # can't write columns containing lists

```

NB: there are 1688 unique ID's in patients and it's 1747 rows long because some people are represented in 2 communes.

Are all the records in the small dataset in the big one? No

```{r}
clinical %>% filter(id %in% clinical_small$id)

```

Assume this is because the big clinical dataset only has people with autism, not ADHD.


Only try to link clinical data to records in the schools data for the Southern health service in Araucanía (ARAUC) because that's where the clinical data is from.

```{r set up data}
school <- chile_merged %>%
  # mutate(commune_code = ifelse(nchar(as.character(student_commune_code)) == 4,
  #                              paste0("0", as.character(student_commune_code)),
  #                              as.character(student_commune_code))) %>%
  select(-student_commune_name) %>%
  left_join(commune_region_lookup, by = "commune_code") %>%
  filter(commune_code %in% araucsur_communes$commune_code) %>%
  #filter(health_service_name == "Servicio de Salud Araucanía Sur") %>% # This should be filtered either on the specific ARAUC communes in the clinical data or using student_commune_region not school_region.
  filter(age_june30 >= 6 & age_june30 <= 18, sex != 0) %>% # Could try without this filter to pick up edge cases just in case
  # filter only the communes represented in the clinical data here?
  mutate(autism = ifelse(special_needs_code == 105, 1, 0),
         #intdisab = 0,
         aut_rank = 1,
         dob = ymd(dob),
         ses_status = ifelse(school_fee == "", NA, 
                      ifelse(school_fee == "GRATUITO", 1, 
                      ifelse(school_fee == "$1.000 A $10.000", 2,
                      ifelse(school_fee == "$10.001 A $25.000", 2, 
                      ifelse(school_fee == "$25.001 A $50.000", 2,
                      ifelse(school_fee == "$50.001 A $100.000", 2, 
                      ifelse(school_fee == "MAS DE $100.000", 2, 
                      ifelse(school_fee == "SIN INFORMACION", NA, NA))))))))) %>%
  filter(autism == 1) %>% # We only want to find additional autism cases in the clinical records, we don't care if a student has autism and isn't in the clinical records
  rename(student_commune_name = commune_name) %>%
  select(dob,
         sex_desc,
         student_commune_name,
         #commune_name, 
         #health_service_name,
         autism,
         ses_status,
         #intdisab,
         aut_rank#,
         #student_region_name
  ) %>%
  rowid_to_column("id")
school[dim(school)[1]+1, ] <- c(dim(school)[1]+1, "2023-06-26", "Female", "Misc", 0, 3, 0)

# Do the commune names align well? Yes
table(sort(unique(patients$student_commune_name, sort(unique(school$student_commune_name)))))
sort(unique(patients$student_commune_name))
sort(unique(school$student_commune_name))

```

Added a fake row at the end of school to have a ses=3 represented so that pairing works.

Perfect match in communes between patient and school dataset when both are filtered to only be communes in Arauc Sur health region.

# Try manual linkage

```{r manual linkage}
patients_grouped <- patients %>%
  group_by(sex_desc, 
           dob, 
           student_commune_name) %>%
  summarise(count = n(),
            ids = list(id))

school_grouped <- school %>%
  group_by(sex_desc, 
           dob, 
           student_commune_name) %>%
  summarise(count = n(),
            #ids = list(rowid)
            ses = list(ses_status))


sort(unique(patients$student_commune_name))
sort(unique(school$student_commune_name))

merged <- merge(school, patients, by = c("sex_desc", "dob", "student_commune_name"), all = FALSE)
merged %>% filter(!is.na(id.x) & !is.na(id.y)) # 205 matches
length(unique(merged$id.x))
length(unique(merged$id.y))

```


187 unique school records can be perfectly matched to clinical records, representing 191 patients.


# Probabilistic record linkage

https://rpubs.com/ahmademad/RecordLinkage
https://www.bristol.ac.uk/media-library/sites/cmm/migrated/documents/problinkage.pdf
https://cran.r-project.org/web/packages/diyar/vignettes/links.html

```{r probabilistic EM, include = FALSE}
# a <- compare.linkage(school,
#                      #select(school, -ses_status), 
#                      select(patients, -row_id),
#                      #select(patients, -ses_status), 
#                      blockfld = c("sex_desc"), # Block on sex because we really want it to be the same and help computation time
#                      #blockfld = FALSE,
#                      phonetic = FALSE,
#                      strcmp = c(2), # Do string comparison on DOB
#                      exclude = c(1) # Exclude the id column in both datasets
#                      )
# a_pairs <- a$pairs
# b <- emWeights(a, cutoff = c(0.99, 0.99, 0.85, 0.6)) # We don't mind some mismatching on commune and ses
# summary(b)
# allPairs <- getPairs(b)
# head(allPairs, n = 20)
# 
# finalPairs <- getPairs(b, max.weight = 14, min.weight = 2) # Take all with perfect match on dob
# head(finalPairs)

```

Mismatch on ses is slightly higher weighted than match on everything. Unclear why and doesn't occur for epiWeights() below.

```{r probabilistic W}
# Try supplying error information. Works better when sex_desc and dob are both in blocking as otherwise allows dob mismatches too easily
# Still quick for whole school dataset
a2 <- compare.linkage(school,
                     #select(school, -ses_status), 
                     select(patients, -row_id),
                     #select(patients, -ses_status), 
                     blockfld = c("sex_desc", "dob"), # Block on sex and dob because we really want them to be the same and help computation time
                     #blockfld = FALSE,
                     phonetic = FALSE,
                     strcmp = c(2), # Do string comparison on DOB
                     exclude = c(1) # Exclude the id column in both datasets
                     )
a2_pairs <- a2$pairs # Issue with ses matching here
b2 <- epiWeights(a2, e = c(0.01, # Default for DOB
                           0.01, # Default for sex
                           0.01, # Default for commune because we want a good match
                           0.01, # Keep small so autism in clinical (not intellectual disability) is prioritised over ses match
                           0.4, # Have more error for ses_status because it is loosely defined 
                           #0.3, # Allow more mismatch intellectual disability status so that autism matches in preference
                           0.01 # Allow some mismatch on whether autism is the primary diagnosis so we take record with higher placed autism diagnosis when there are multiple clinical record options for a single school record
))
summary(b2)
allPairs2 <- getPairs(b2)
head(allPairs2, n = 20)

classifyPairs2 <- emClassify(b2, threshold.upper = 1, threshold.lower = 0.8)
a2_pairs$weight <- classifyPairs2$Wdata
a2_pairs$pred <- classifyPairs2$prediction

a2_pairs_clean <- a2_pairs %>%
  rename(".x" = id1, ".y" = id2) %>%
  select(-is_match)

finalPairs2 <- getPairs(b2, max.weight = 1, min.weight = 0, single.rows = TRUE) # Take them all when blocked on sex_desc and dob together

#kmeansRes2 <- classifyUnsup(a2, method = "kmeans")
#a2_pairs$pred <- kmeansRes2$prediction
# Works but prioritises ses over commune and doesn't use epiWeights found above so not that useful.


```

finalPairs2 is the same size as finalPairs and probably contains the same matches but was much quicker to run because of the blocking.
Assume in kmeansRes2, N = not a match, L = likely a match.


```{r matches}

# reclin has a 1-1 matching fuction so regenerate the pairs using reclin so they're a pairs
# type object and can be passed to select_n_to_m

pairs <- pair_blocking(school, patients, on = c("sex_desc", "dob")) %>%
         mutate(student_commune_name = (school$student_commune_name[.x] == patients$student_commune_name[.y])#,
         #ses = get_num_diff(school$ses_status[.x], patients$ses_status[.y])$val
         ) %>%
  left_join(a2_pairs_clean, by = c(".x", ".y")) %>%
  select(c(-student_commune_name.x)) %>%
  rename("student_commune_name" = "student_commune_name.y")


matches <- select_n_to_m(pairs, threshold = 0.5, score = "weight", n = 1, m = 1, var = "match") %>%
  filter(match == TRUE) %>%
  rename("id" = ".x",
         "row_id" = ".y") %>%
  mutate(id = as.character(id))

```

```{r match school}

# Now add the matched clinical records to the school records
school_matched <- school %>%
  filter(student_commune_name != "Misc") %>%
  left_join(matches, by = "id") %>%
  rename(id.school = id,
         dob.school = dob.x,
         sex_desc.school = sex_desc.x,
         student_commune_name.school = student_commune_name.x,
         ses_status.school = ses_status.x,
         dob.matched = dob.y,
         sex_desc.matched = sex_desc.y,
         student_commune_name.matched = student_commune_name.y,
         ses_status.matched = ses_status.y) %>%
  select(c(-pred, -match)) %>%
  left_join(patients, by = "row_id") %>%
  rename(id.patient = row_id,
         patient_id = id,
         dob.patient = dob,
         sex_desc.patient = sex_desc,
         student_commune_name.patient = student_commune_name,
         ses_status.patient = ses_status) %>%
  select(id.school, id.patient, patient_id,
         dob.school, dob.patient, dob.matched,
         sex_desc.school, sex_desc.patient, sex_desc.matched,
         student_commune_name.school, student_commune_name.patient, student_commune_name.matched,
         ses_status.school, ses_status.patient, ses_status.matched,
         weight) %>%
  arrange(desc(weight))

write_csv(school_matched, "04_Data/Outputs/school_matched.csv")

#school_matched_yes <- school_matched %>% filter(!is.na(weight))
#school_matched_no <- school_matched %>% filter(is.na(weight))

# commune_nums <- data.frame(student_commune_name.school = sort(unique(school_matched$student_commune_name.school)),
#                            commune_num = c(1:length(unique(school_matched$student_commune_name.school))))

school_matched_small <- school_matched %>%
  mutate(matched = ifelse(is.na(patient_id), 0, 1),
         sex.school = ifelse(sex_desc.school == "Male", 1, ifelse(sex_desc.school == "Female", 2, NA))) %>%
  merge(commune_region_lookup, by.x = "student_commune_name.school", by.y = "commune_name") %>% # doesn't include all.x = TRUE because that would keep the fake record.
  select(id.school, dob.school, sex_desc.school, sex.school, student_commune_name.school, commune_code, ses_status.school, matched)

```

```{r match patient}

# Now add the matched clinical records to the school records
patients_matched <- patients %>%
  left_join(matches, by = "row_id") %>%
  rename(id.patient = row_id,
         patient_id = id.x,
         dob.patient = dob.x,
         sex_desc.patient = sex_desc.x,
         student_commune_name.patient = student_commune_name.x,
         id = id.y,
         ses_status.patient = ses_status.x,
         dob.matched = dob.y,
         sex_desc.matched = sex_desc.y,
         student_commune_name.matched = student_commune_name.y,
         ses_status.matched = ses_status.y) %>%
  select(c(-pred, -match)) %>%
  left_join(school, by = "id") %>%
  rename(id.school = id,
         dob.school = dob,
         sex_desc.school = sex_desc,
         student_commune_name.school = student_commune_name,
         ses_status.school = ses_status) %>%
  select(id.school, id.patient, patient_id,
         dob.school, dob.patient, dob.matched,
         sex_desc.school, sex_desc.patient, sex_desc.matched,
         student_commune_name.school, student_commune_name.patient, student_commune_name.matched,
         ses_status.school, ses_status.patient, ses_status.matched,
         weight) %>%
  arrange(desc(weight))

write_csv(patients_matched, "04_Data/Outputs/patients_matched.csv")


patients_matched_small <- patients_matched %>%
  mutate(matched = ifelse(is.na(id.school), 0, 1),
         sex.patient = ifelse(sex_desc.patient == "Male", 1, ifelse(sex_desc.patient == "Female", 2, NA))) %>%
  merge(commune_region_lookup, by.x = "student_commune_name.patient", by.y = "commune_name") %>%
  select(patient_id, id.patient, dob.patient, sex_desc.patient, sex.patient, student_commune_name.patient, commune_code, ses_status.patient, matched)

```


Check patients that lived in different communes therefore were in the patient dataset twice aren't matched to multiple school records

```{r patients unique}
patients_matched_unique <- patients_matched_small %>%
  group_by(matched, patient_id) %>%
  summarise(count = n())

patients_dup <- patients_matched_unique %>% filter(matched == 1, count > 1) %>% select(patient_id)
# No patient is inadvertently matched to two school records

```

## Consider whether the matched and unmatched school records are different

We hope they are not different

```{r kolmogorov explore, warning = TRUE}
#library(coin)


#pt.sex <- oneway_test(sex.school ~ as.factor(matched), data = school_matched_small, distribution = approximate(nresample = 2000))
#confint(pt.sex)

#ks.ses <- ks.test(data1$ses_status.school, data2$ses_status.school, alternative = "two.sided", simulate.p.value = TRUE)
#ks.ses

# SES
#data1 <- school_matched_yes %>% select(ses_status.school)
#data2 <- school_matched_no %>% select(ses_status.school)
#hist(data1$ses_status.school, breaks = 10)
#hist(data2$ses_status.school, breaks = 10)
#$data1 %>% group_by(ses_status.school) %>% summarise(count = n()) %>% mutate(freq = count/sum(count))
#data2 %>% group_by(ses_status.school) %>% summarise(count = n()) %>% mutate(freq = count/sum(count))

```

```{r kolmogorov tests school, warning = FALSE}

school_yes <- school_matched_small %>% filter(matched == 1) #%>% select(sex.school)
school_no <- school_matched_small %>% filter(matched == 0)

# Kolmogorov tests for our matched results
ks.school.sex <- ks.test(na.omit(school_yes$sex.school),
                         na.omit(school_no$sex.school),
                         alternative = "two.sided", simulate.p.value = TRUE)
ks.school.sex

ks.school.ses_status <- ks.test(as.numeric(na.omit(school_yes$ses_status.school)),
                                as.numeric(na.omit(school_no$ses_status.school)),
                                alternative = "two.sided", simulate.p.value = TRUE)
ks.school.ses_status

ks.school.commune_code<- ks.test(as.numeric(na.omit(school_yes$commune_code)),
                                 as.numeric(na.omit(school_no$commune_code)),
                                 alternative = "two.sided", simulate.p.value = TRUE)
ks.school.commune_code

# Try manual Kolmogorov for SES
# bins <- unique(na.omit(school_matched_small$ses_status.school))
# ecdf.ses_status.yes <- ecdf(schoolyes$ses_status.school)
# ecdf.ses_status.yes(schoolyes$ses_status.school)
# ecdf.ses_status.no <- ecdf(schoolno$ses_status.school)
# plot(ecdf.ses_status.yes) ; plot(ecdf.ses_status.no)

# Kolmogorov tests with permutation distributions
set.seed(123)
nPerm <- 200 # change to 2000
ks_perm.school.pvals <- data.frame(sex = numeric(nPerm),
                                   commune_code = numeric(nPerm),
                                   ses_status = numeric(nPerm))

school_matched_small_perm <- school_matched_small

for (i in 1:nPerm) {
  #print(i)
  school_matched_small_perm$matched <- school_matched_small$matched[sample(nrow(school_matched_small))] # permute matched status
  school_perm_yes <- school_matched_small_perm %>% filter(matched == 1)
  school_perm_no <- school_matched_small_perm %>% filter(matched == 0)
  
  ks_perm.school.sex <- ks.test(na.omit(school_perm_yes$sex.school),
                                na.omit(school_perm_no$sex.school), 
                                alternative = "two.sided")
  ks_perm.school.commune_code <- ks.test(as.numeric(na.omit(school_perm_yes$commune_code)),
                                        as.numeric(na.omit(school_perm_no$commune_code)),
                                        alternative = "two.sided")
  ks_perm.school.ses_status <- ks.test(as.numeric(na.omit(school_perm_yes$ses_status.school)),
                                       as.numeric(na.omit(school_perm_no$ses_status.school)),
                                       alternative = "two.sided")
  
  ks_perm.school.pvals$sex[i] <- ks_perm.school.sex$p.value
  ks_perm.school.pvals$commune_code[i] <- ks_perm.school.commune_code$p.value
  ks_perm.school.pvals$ses_status[i] <- ks_perm.school.ses_status$p.value
}

# Results for sex
school_match_yes.sex <- school_yes %>% group_by(sex.school) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 1)
school_match_no.sex <- school_no %>% group_by(sex.school) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 0)
school_match.sex <- rbind(school_match_yes.sex, school_match_no.sex) %>%
  mutate(sex_desc = ifelse(sex.school == 1, "Male", ifelse(sex.school == 2, "Female", NA))) %>% 
  arrange(sex_desc, matched)

ggplot(school_match.sex) +
  geom_col(aes(x = as.factor(matched), y = freq, fill = as.factor(matched))) +
  facet_wrap(~sex_desc) +
  labs(title = "Matching of school record to clinical record by sex",
       x = "Matched status",
       y = "Feature frequency",
       fill = "Matched status")

ggplot(ks_perm.school.pvals, aes(x = sex, y = after_stat(density))) +
  geom_density() +
  geom_vline(xintercept = ks.school.sex$p.value, color = "red")

# Results for commune
school_match_yes.student_commune_name <- school_yes %>% group_by(student_commune_name.school) %>%
  summarise(count = n()) %>% mutate(freq = count/sum(count)) %>%
  # Would need to merge to a list of commune names and numbers if want to display all communes for all matched statuses
  #merge(commune_, by = "commune_num", all = TRUE) %>% 
  mutate(matched = 1) 
school_match_no.student_commune_name <- school_no %>% group_by(student_commune_name.school) %>%
  summarise(count = n()) %>% mutate(freq = count/sum(count)) %>%
  #merge(commune_nums, by = "commune_num", all = TRUE) %>% 
  mutate(matched = 0)

school_match.student_commune_name <- rbind(school_match_yes.student_commune_name, school_match_no.student_commune_name) %>%
  arrange(student_commune_name.school, matched)

ggplot(school_match.student_commune_name) +
  geom_col(aes(x = as.factor(matched), y = freq, fill = as.factor(matched))) +
  facet_wrap(~student_commune_name.school, scales = "fixed") +
  #facet_wrap(~student_commune_name.school, scales = "free") +
  labs(title = "Matching of school record to clinical record by commune",
       x = "Matched status",
       y = "Feature frequency",
       fill = "Matched status")
# most of the difference in matched commune frequency is for Temuco which is the biggest commune.


ggplot(ks_perm.school.pvals, aes(x = commune_code, y = after_stat(density))) +
  geom_density() +
  geom_vline(xintercept = ks.school.commune_code$p.value, color = "red")

# Results for ses status
school_match_yes.ses_status <- school_yes %>% group_by(ses_status.school) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 1)
school_match_no.ses_status <- school_no %>% group_by(ses_status.school) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 0)
school_match.ses_status <- rbind(school_match_yes.ses_status, school_match_no.ses_status) %>%
  arrange(ses_status.school, matched)

ggplot(school_match.ses_status) +
  geom_col(aes(x = as.factor(matched), y = freq, fill = as.factor(matched))) +
  facet_wrap(~ses_status.school) +
  labs(title = "Matching of school record to clinical record by SES status",
       x = "Matched status",
       y = "Feature frequency",
       fill = "Matched status")

ggplot(ks_perm.school.pvals, aes(x = ses_status, y = after_stat(density))) +
  geom_density() +
  geom_vline(xintercept = ks.school.ses_status$p.value, color = "red")


```

Bit easier to match SES status of 1 (probably more common)

Our matched/non-matched are not different by sex (p-value in Kolmog is same as most of distribution of permuted pvals) but are different by commune and ses status. Cohen's D test isn't suitable to compare the matched and un-matched because the data don't have standard deviations.

??Add commune maps here with size of sample for school and clinical?? Also size of other features.


```{r kolmogorov tests patient, warning = FALSE}

patients_yes <- patients_matched_small %>% filter(matched == 1) #%>% select(sex.school)
patients_no <- patients_matched_small %>% filter(matched == 0)

# Kolmogorov tests for our matched results
ks.patients.sex <- ks.test(na.omit(patients_yes$sex.patient),
                         na.omit(patients_no$sex.patient),
                         alternative = "two.sided", simulate.p.value = TRUE)
ks.patients.sex

ks.patients.ses_status <- ks.test(as.numeric(na.omit(patients_yes$ses_status.patient)),
                                as.numeric(na.omit(patients_no$ses_status.patient)),
                                alternative = "two.sided", simulate.p.value = TRUE)
ks.patients.ses_status

ks.patients.commune_code<- ks.test(as.numeric(na.omit(patients_yes$commune_code)),
                                 as.numeric(na.omit(patients_no$commune_code)),
                                 alternative = "two.sided", simulate.p.value = TRUE)
ks.patients.commune_code


# Kolmogorov tests with permutation distributions
set.seed(123)
nPerm <- 200 # change to 2000
ks_perm.patients.pvals <- data.frame(sex = numeric(nPerm),
                                   commune_code = numeric(nPerm),
                                   ses_status = numeric(nPerm))

patients_matched_small_perm <- patients_matched_small

for (i in 1:nPerm) {
  #print(i)
  patients_matched_small_perm$matched <- patients_matched_small$matched[sample(nrow(patients_matched_small))] # permute matched status
  patients_perm_yes <- patients_matched_small_perm %>% filter(matched == 1)
  patients_perm_no <- patients_matched_small_perm %>% filter(matched == 0)
  
  ks_perm.patients.sex <- ks.test(na.omit(patients_perm_yes$sex.patient),
                                na.omit(patients_perm_no$sex.patient), 
                                alternative = "two.sided")
  ks_perm.patients.commune_code <- ks.test(as.numeric(na.omit(patients_perm_yes$commune_code)),
                                        as.numeric(na.omit(patients_perm_no$commune_code)),
                                        alternative = "two.sided")
  ks_perm.patients.ses_status <- ks.test(as.numeric(na.omit(patients_perm_yes$ses_status.patient)),
                                       as.numeric(na.omit(patients_perm_no$ses_status.patient)),
                                       alternative = "two.sided")
  
  ks_perm.patients.pvals$sex[i] <- ks_perm.patients.sex$p.value
  ks_perm.patients.pvals$commune_code[i] <- ks_perm.patients.commune_code$p.value
  ks_perm.patients.pvals$ses_status[i] <- ks_perm.patients.ses_status$p.value
}

# Results for sex
patients_match_yes.sex <- patients_yes %>% group_by(sex.patient) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 1)
patients_match_no.sex <- patients_no %>% group_by(sex.patient) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 0)
patients_match.sex <- rbind(patients_match_yes.sex, patients_match_no.sex) %>%
  mutate(sex_desc = ifelse(sex.patient == 1, "Male", ifelse(sex.patient == 2, "Female", NA))) %>% 
  arrange(sex_desc, matched)

ggplot(patients_match.sex) +
  geom_col(aes(x = as.factor(matched), y = freq, fill = as.factor(matched))) +
  facet_wrap(~sex_desc) +
  labs(title = "Matching of clinical record to school record by sex",
       x = "Matched status",
       y = "Feature frequency",
       fill = "Matched status")

ggplot(ks_perm.patients.pvals, aes(x = sex, y = after_stat(density))) +
  geom_density() +
  geom_vline(xintercept = ks.patients.sex$p.value, color = "red")

# Results for commune
patients_match_yes.student_commune_name <- patients_yes %>% group_by(student_commune_name.patient) %>%
  summarise(count = n()) %>% mutate(freq = count/sum(count)) %>%
  # Would need to merge to a list of commune names and numbers if want to display all communes for all matched statuses
  #merge(commune_, by = "commune_num", all = TRUE) %>% 
  mutate(matched = 1) 
patients_match_no.student_commune_name <- patients_no %>% group_by(student_commune_name.patient) %>%
  summarise(count = n()) %>% mutate(freq = count/sum(count)) %>%
  #merge(commune_nums, by = "commune_num", all = TRUE) %>% 
  mutate(matched = 0)

patients_match.student_commune_name <- rbind(patients_match_yes.student_commune_name, patients_match_no.student_commune_name) %>%
  arrange(student_commune_name.patient, matched)

ggplot(patients_match.student_commune_name) +
  geom_col(aes(x = as.factor(matched), y = freq, fill = as.factor(matched))) +
  facet_wrap(~student_commune_name.patient, scales = "fixed") +
  #facet_wrap(~student_commune_name.school, scales = "free") +
  labs(title = "Matching of clinical record to school record by commune",
       x = "Matched status",
       y = "Feature frequency",
       fill = "Matched status")
# most of the difference in matched commune frequency is for Temuco which is the biggest commune.


ggplot(ks_perm.patients.pvals, aes(x = commune_code, y = after_stat(density))) +
  geom_density() +
  geom_vline(xintercept = ks.patients.commune_code$p.value, color = "red")

# Results for ses status
patients_match_yes.ses_status <- patients_yes %>% group_by(ses_status.patient) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 1)
patients_match_no.ses_status <- patients_no %>% group_by(ses_status.patient) %>% summarise(count = n()) %>% mutate(freq = count/sum(count), matched = 0)
patients_match.ses_status <- rbind(patients_match_yes.ses_status, patients_match_no.ses_status) %>%
  arrange(ses_status.patient, matched)

ggplot(patients_match.ses_status) +
  geom_col(aes(x = as.factor(matched), y = freq, fill = as.factor(matched))) +
  facet_wrap(~ses_status.patient) +
  labs(title = "Matching of clinical record to school record by SES status",
       x = "Matched status",
       y = "Feature frequency",
       fill = "Matched status")

ggplot(ks_perm.patients.pvals, aes(x = ses_status, y = after_stat(density))) +
  geom_density() +
  geom_vline(xintercept = ks.patients.ses_status$p.value, color = "red")


```


# New prevalence estimates

```{r new prev}
n_aut_araucS <- nrow(school_matched) + length(unique(patients_matched$patient_id)) - nrow(matches) # Use this version because accounts for non-unique patients with both match and non-match
#n_aut_araucS <- school_matched_small %>% filter(matched == 0) %>% nrow() +
#  dim(patients_matched_small %>% filter(matched == 0) %>% select(patient_id) %>% unique())[1] + nrow(matches)


```


# CFA for clinical data

```{r cfa}
clinical_fa <- clinical %>%
  mutate(sex_desc = ifelse(gender == "Male", 1, ifelse(gender == "Female", 2, NA)),
         appt_type = ifelse(type_appointment == "New", 1,
                            ifelse(type_appointment == "Control" | type_appointment == "CONTROL", 2,
                                   ifelse(type_appointment == "Discharge", 3, NA))),
         commune_code = as.numeric(commune_code),
         ses_detailed = ifelse(socio_economic_level == "FONASA - A", 1, 
                      ifelse(socio_economic_level == "FONASA - B", 2,
                      ifelse(socio_economic_level == "FONASA - C", 3, 
                      ifelse(socio_economic_level == "FONASA - D", 4,
                      ifelse(socio_economic_level == "Private Health Insurance", 5, 
                      ifelse(socio_economic_level %in% c("COLMENA GOLDEN CROSS", "RIO BLANCO", "CARABINEROS (DIPRECA)", "BANMEDICA S.A.", "PARTICULAR (SIN PREVISION)", "VIDA TRES"), 5, NA))))))) %>%
  select(id, sex_desc, age_june30, ses_detailed, appt_type)
# would like to have medical specialty here too

# Using all sn categories together isn't really legit
clinical_cor <- cor(select(clinical_fa, c(-id)), use = "pairwise")
clinical_cor
corrplot(clinical_cor)
clinical_eigen <- eigen(clinical_cor)
clinical_eigen$values
scree(clinical_cor) # , factors = FALSE) # PC is principle components, FA is factors
# Only keep the factors that have eigenvalue above 1. Will use PC results for now https://www.researchgate.net/post/Both-PC-and-FA-in-scree-plot-which-to-use-in-an-EFA
# There are 4 such factors.

clinical_efa <- fa(select(clinical_fa, c(-id)), nfactors = 2)
clinical_efa


```







# Dumping ground, don't use below here.


# Record linkage using machine learning

Try linkage using ML, as done by Jan van der Laan here https://cran.r-project.org/web/packages/reclin2/vignettes/record_linkage_using_machine_learning.html 

```{r similarity functions, include = FALSE}
# get_num_diff <- function(.x, .y) {
#   diff_value <- data.frame(.x = .x, .y = .y, val = numeric(length(.x)))
#   diff_value <- diff_value %>%
#     mutate(val = ifelse(abs(.x-.y) == 0, 1, 
#                         ifelse(abs(.x-.y) <= 1, 0.5,
#                                ifelse(abs(.x-.y) <= 2, 0.25, 
#                                       ifelse(abs(.x-.y) <= 3, 0.125, 0)))))
#   
#   return(diff_value)
# }

```


```{r pairs, include = FALSE}

    
# get_num_diff(c(1, 2, 3), c(1, 1, 1))
# get_num_diff(1, 2)$val
# 
# # Generate pairs
# # use smaller clinical data for now to get it working
# pairs <- # Also try without the blocking 
#          pair_blocking(school, patients, on = c("sex_desc", "dob")) %>%
#          #pair(x = patients, y = school) %>%
#   mutate(#age_june30 = get_num_diff(patients$age_june30[.x], school$age_june30[.y])$val,
#          #dob = get_num_diff(patients$dob[.x], school$dob[.y])$val,
#          #dob = patients$dob[.x] == school$dob[.y],
#          #school_commune_name = (patients$school_commune_name[.x] == school$school_commune_name[.y])# will need a better commune similarity algorithm
#          student_commune_name = (school$student_commune_name[.x] == patients$student_commune_name[.y]),
#          #sex_desc = patients$sex_desc[.x] == school$sex_desc[.y],
#          ses = get_num_diff(school$ses_status[.x], patients$ses_status[.y])$val
#          #ses_pat = patients$ses_status[.x],
#          #ses_sch = school$ses_status[.y]
#          ) 
# 
# pairs_match <- pairs %>% filter(student_commune_name == TRUE)
# # Vast majority of school records are free (1).
# 
# # Try k-means clustering
# set.seed(123)
# k <- 2 # We know there are 2 classes: matched records and un-matched records, and we'd like a 3rd class for maybes
# kmeans_result <- kmeans(select(pairs, c(-.x, -.y)), k, nstart = 20)
# pairs$k_pred <- predict(kmeans_result, select(pairs, c(-.x, -.y)))
# #table(pairs$pred)
# #table(pairs$dob, pairs$student_commune_name, pairs$sex_desc, pairs$pred)
# pairs_grouped <- pairs %>% group_by(#k_pred, 
#                                     #sex_desc, 
#                                     student_commune_name, 
#                                     #dob, 
#                                     ses
#                                     #ses_pat, ses_sch
#                                     ) %>% summarise()

```

```{r unsupervised ML, include = FALSE}

# Not very useful

# pairs %>% filter(k_pred == 1) %>% summary()
# pairs %>% filter(k_pred == 2) %>% summary()
# #pairs %>% filter(k_pred == 3) %>% summary()
# 
# 
# # Try c-means clustering
# set.seed(123)
# c <- 2
# pairs_trues <- pairs %>% filter((dob == TRUE & student_commune_name == TRUE) |
#                                   (dob == TRUE & sex_desc == TRUE) |
#                                   (student_commune_name == TRUE & sex_desc == TRUE)) %>% select(-k_pred) # Remove clearly unmatched rows to help computation time
# v <- inaparc::kmpp(select(pairs_trues, c(-.x, -.y)), k = c)$v
# u <- inaparc::imembrand(nrow(pairs_trues), k = c)$u
# cmeans_result <- fcm(select(pairs_trues, c(-.x, -.y)),
#                      centers = v, # Starting centers to trial
#                      memberships = u,
#                      m = 2, # Fuzziness, keep as 2
#                      dmetric = "sqeuclidean", # Distance between points - may not be suitable for binary variables
#                      nstart = 1) # Number of repeats
# pairs_trues$c_pred <- cmeans_result$cluster
# cmeans_result$u
# 
# pairs_trues %>% filter(c_pred == 1) %>% summary()
# pairs_trues %>% filter(c_pred == 2) %>% summary()
# 
# Compare pairs - takes a couple of minutes to run with blocking on sex
#compare_pairs(pairs, on = c("age_june30", "dob", "school_commune_name"), 
#              comparators = list(#age_june30 = get_num_diff(.x, .y)#, # For now, require exact match on age
#                                 dob = jaro_winkler() #, 
#                                 #school_commune_name = jaro_winkler() # For now, require exact match on commune
#                                 ),
#              inplace = TRUE # Allows pairs to be modified in place - makes it more efficient when pairs is large
#              )
# No need to assign this to anything, it updates pairs with additional columns
# compare_pairs() works for patients_small + school (174,173 pairs) but doesn't work for patients + school (655,680 pairs)
# Can't handle more than approx 400,000 pairs


```

In reclin2 package, use ?identical() to see available matching algorithms.

The Jaro-Winkler distance is a string metric for measuring the edit distance between two sequences. It is a variant of the Jaro distance metric proposed by William E. Winkler in 1990 1. The Jaro-Winkler distance uses a prefix scale which gives more favorable ratings to strings that match from the beginning for a set prefix length. The higher the Jaro-Winkler distance for two strings is, the less similar the strings are. The score is normalized such that 0 means an exact match and 1 means there is no similarity 1.

Need to explore different comparator algorithms. Currently it's exact match. Would be good to do communes that are neighbours and ages off by 1.


# Try bayesian linkage?

Follow Thomas Stringham https://arxiv.org/pdf/2003.04238.pdf
who followed Sadinle https://arxiv.org/abs/1601.06630
Not doing this as limited value when not matching strings.















